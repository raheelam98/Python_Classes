## **Coding Patterns Cheat Sheet**

Common problem-solving patterns in Data Structures & Algorithms (DSA) and coding interviews:

- **Sliding Window** → Used in substring problems, max/min in subarrays.  
- **Two Pointer** → Used in sorting, arrays, and linked list problems.  
- **Modified Binary Search** → For finding first/last occurrence, ceiling/floor, or other variations in sorted arrays.  
- **Binary Tree BFS** → Level-order traversal, shortest path in tree/graph.  
- **Binary Tree DFS** → Preorder, Inorder, Postorder traversal for tree problems.  
- **Top K Elements** → Find most frequent, largest, or smallest K items using heaps/priority queues.  
- **Subset** → Generate subsets, combinations, or power set of elements.  
- **Topological Sort** → Task scheduling, dependency resolution in Directed Acyclic Graph (DAG).  
- **Fast & Slow Pointer** → Detect cycles, find middle node in linked lists.  
- **Backtracking** → Used for permutations, combinations, Sudoku, N-Queens, and constraint-solving problems.  

#### **Why These Matter**
These patterns are building blocks for solving complex problems efficiently.  
Learning to recognize them will help you approach coding interviews with confidence.

--- 
#### **Coding Patterns Detail**

These are the most common **problem-solving patterns** in Data Structures & Algorithms (DSA) and coding interviews.  
They provide reusable approaches to solve a wide variety of problems efficiently.

### 1. Sliding Window
Used for problems involving subarrays or substrings by maintaining a moving "window" over data.  
**Example:** Maximum sum of subarray of size K.

### 2. Two Pointer
Uses two pointers moving at different speeds or directions to reduce complexity.  
**Example:** Check if an array has a pair that sums to a target.

### 3. Modified Binary Search
Adapts binary search logic for problems beyond exact match.  
**Example:** Find first or last occurrence of a number in a sorted array.

### 4. Binary Tree BFS
Traverses a binary tree level by level using a queue.  
**Example:** Find shortest path in a binary tree.

### 5. Binary Tree DFS
Traverses a binary tree depth-first (Preorder, Inorder, Postorder).  
**Example:** Validate if a binary tree is a BST.

### 6. Top K Elements
Finds the largest, smallest, or most frequent K elements using heaps/priority queues.  
**Example:** Top K frequent words in a list.

### 7. Subset
Generates all subsets or combinations of elements (power set problems).  
**Example:** Generate all subsets of a set of numbers.

### 8. Topological Sort
Orders nodes in a Directed Acyclic Graph (DAG) while respecting dependencies.  
**Example:** Task scheduling with prerequisites.

### 9. Fast & Slow Pointer
Uses two pointers at different speeds to detect cycles or find midpoints.  
**Example:** Detect a cycle in a linked list.

### 10. Backtracking
Recursively builds solutions, undoing steps when needed (try-and-error approach).  
**Example:** Solve Sudoku or N-Queens problem.


###  Why Learn These?
Mastering these patterns helps you:
- Solve coding interview questions efficiently.  
- Recognize hidden patterns in complex problems.  
- Write cleaner and optimized solutions.


